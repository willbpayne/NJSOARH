---
title: "PLACE_to_Cousub_Crosswalk_for_PSH"
author: "Will Payne"
date: "5/123/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

########################################
## 1 - Setup and Initializing Dataset ##
########################################

library(sf) # use this to read geojsons and shapefiles
library(tmap) # use this to map them
library(dplyr) # use this to join and manipulate data frames
library(tidyverse)
#library(PROJ) # necessary?
#library(transformr) # necessary?

place_PSH_2022 <- read.csv(file = 'PLACE_2022.csv') # read in national place-level data

state_name <- 'NJ New Jersey' # set this once and everything flows from here
place_PSH <- place_PSH_2022 %>% filter(grepl(state_name, states)) # filter to single state
state_code <- substr(head(place_PSH,1)$code,1,2) # store state code

place_PSH <- subset(place_PSH, select = -c(gsl,states,sumlevel,sub_program,entities, fedhse, cbsa, latitude, longitude, state, pha_total_units, ha_size)) # remove unneeded columns
place_PSH[place_PSH==-1]<-0 # replace -1 with 0 throughout (missing data)
place_PSH[place_PSH==-4]<-NA # replace -4 with NA throughout (suppressed demographic data)
place_PSH[place_PSH==-5]<-NA # replace -5 with NA throughout (reporting under 50% demographic data)

##########################################
## 2 - Combining Data from All Programs ##
##########################################

prefixes <- unique(place_PSH$program) # get all the unique program names used in the dataset

place_PSH <- pivot_wider( # pivot them to one row per cdp/cousub/remainder
  place_PSH,
  id_cols = NULL,
  names_from = program,
  names_prefix = "",
  names_sep = "_",
  names_glue = "Pg{program}_{.value}",
  values_from = c(program_label,total_units,pct_occupied,number_reported,pct_reported,months_since_report,months_since_report,pct_movein,people_per_unit,people_total,rent_per_month,spending_per_month,hh_income,person_income,pct_lt5k,pct_5k_lt10k,pct_10k_lt15k,pct_15k_lt20k,pct_ge20k,pct_wage_major,pct_welfare_major,pct_other_major,pct_median,pct_lt50_median,pct_lt30_median,pct_2adults,pct_1adult,pct_female_head,pct_female_head_child,pct_disabled_lt62,pct_disabled_ge62,pct_disabled_all,pct_lt24_head,pct_age25_50,pct_age51_61,pct_age62plus,pct_age85plus,pct_minority,pct_black_nonhsp,pct_native_american_nonhsp,pct_asian_pacific_nonhsp,pct_white_nothsp,pct_black_hsp,pct_wht_hsp,pct_oth_hsp,pct_hispanic,pct_multi,months_waiting,months_from_movein,pct_utility_allow,ave_util_allow,pct_bed1,pct_bed2,pct_bed3,pct_overhoused,tpoverty,tminority,tpct_ownsfd),
  names_sort = TRUE
)

# sort the dataframe so that each set of unit counts and demographic variables are together by program
names_to_order <- map(prefixes, ~ names(place_PSH)[grep(paste0(.x,"_"), names(place_PSH))]) %>% unlist
names_id <- setdiff(names(place_PSH), names_to_order)
place_PSH <- place_PSH %>%
  select(all_of(names_id), names_to_order)

rm(names_id, names_to_order) # remove intermediate outputs

#####################################
## 3 - Split Dataset by Error Type ##
#####################################

code_99999 <- paste(state_code, '99999', sep='') # state geoid for unjoinable geographies
code_XXXXX <- paste(state_code, 'XXXXX', sep='') # state geoid for units lacking location information

place_PSH_CDPs <- place_PSH %>% filter(grepl('CDP', name)) # extract CDPs
place_PSH_no_CDPs <- place_PSH %>% filter(!grepl('CDP', name)) # remove CDPs from the main dataset
place_PSH_999999s <- filter(place_PSH_no_CDPs, code == code_9999) # extract rows without geoids, including remainders
place_PSH_geoID <- filter(place_PSH_no_CDPs, code != code_9999) # extract non-CDPs with working geoids
place_PSH_remainders <- place_PSH_999999s %>% filter(grepl('REMAINDER', name)) # extract remainders of cousubs
place_PSH_othercousubs <- place_PSH_999999s %>% filter(!grepl('REMAINDER', name)) # extract other cousubs without geoids
place_PSH_XXXXX <- filter(place_PSH_no_CDPs, code == code_XX) # extract missing values (unmappable)

#######################################
## 4 - Find Unjoinable Units by Type ##
#######################################

# We do this before anything else in order to have a sense of the scope of the problem

unjoinable_units_by_type <- data.frame(matrix(ncol = 7, nrow = 9))
colnames(unjoinable_units_by_type) <- c("Pg","Name", "Total_units", "unjoin_Missing","unjoin_CDP", "unjoin_Remainder","unjoin_99999")
unjoinable_units_by_type$Pg <- 1:9
unjoinable_units_by_type$Name <- c("All Programs", "Public Housing", "Housing Choice Vouchers", "Moderate Rehabilitation", "Project Based Section 8", "RentSup/RAP", "S236/BMIR", "202/PRAC", "811/PRAC")
  
for(i in 1:length(prefixes)) { # Loop to get unjoinable by type of error and program number
  totalname <- paste('Pg', as.character(prefixes[i]), '_total_units', sep = "")

  unjoinable_99999_column <- place_PSH_othercousubs[grepl(totalname,colnames(place_PSH_othercousubs))]
  unjoinable_units_by_type[unjoinable_units_by_type$Pg==prefixes[i], "unjoin_99999"] <- sum(unjoinable_99999_column,na.rm=TRUE)

  unjoinable_CDP_column <- place_PSH_CDPs[grepl(totalname,colnames(place_PSH_CDPs))]
  unjoinable_units_by_type[unjoinable_units_by_type$Pg==prefixes[i], "unjoin_CDP"] <- sum(unjoinable_CDP_column,na.rm=TRUE)

  unjoinable_remainder_column <- place_PSH_remainders[grepl(totalname,colnames(place_PSH_remainders))]
  unjoinable_units_by_type[unjoinable_units_by_type$Pg==prefixes[i], "unjoin_Remainder"] <- sum(unjoinable_remainder_column,na.rm=TRUE)

  missing_column <- place_PSH_XXXXX[grepl(totalname,colnames(place_PSH_XXXXX))]
  unjoinable_units_by_type[unjoinable_units_by_type$Pg==prefixes[i], "unjoin_Missing"] <- sum(missing_column,na.rm=TRUE)

  total_summary_column <- place_PSH[grepl(totalname,colnames(place_PSH))]
  unjoinable_units_by_type[unjoinable_units_by_type$Pg==prefixes[i], "Total_units"] <- sum(total_summary_column,na.rm=TRUE)
  
  rm(i, totalname, unjoinable_99999_column, unjoinable_CDP_column, unjoinable_remainder_column, missing_column, total_summary_column) 
}

unjoinable_units_by_type$total_joinable <- unjoinable_units_by_type$Total_units - unjoinable_units_by_type$unjoin_Missing
unjoinable_units_by_type$unjoin_CDP_Pct <- unjoinable_units_by_type$unjoin_CDP/unjoinable_units_by_type$total_joinable *100
unjoinable_units_by_type$unjoin_Remainder_Pct <- unjoinable_units_by_type$unjoin_Remainder/unjoinable_units_by_type$total_joinable *100
unjoinable_units_by_type$unjoin_99999_Pct <- unjoinable_units_by_type$unjoin_99999/unjoinable_units_by_type$total_joinable *100
unjoinable_units_by_type$total_unjoinable <- unjoinable_units_by_type$unjoin_CDP + unjoinable_units_by_type$unjoin_Remainder + unjoinable_units_by_type$unjoin_99999
unjoinable_units_by_type$total_unjoinable_Pct <- unjoinable_units_by_type$total_unjoinable/unjoinable_units_by_type$total_joinable *100

write.csv(unjoinable_units_by_type, "unjoinable_units_by_type.csv", row.names=FALSE)

####

place_PSH_Cousubs_Already <- rbind(place_PSH_geoID, place_PSH_othercousubs) # get things that are already aggregated to cousub put together here

place_PSH_Cousubs_Already$Join_Name <- str_to_title(substr(place_PSH_Cousubs_Already$name,4,nchar(place_PSH_Cousubs_Already$name))) # create new join field

rm(place_PSH_no_CDPs, place_PSH_geoID, place_PSH_othercousubs, place_PSH_999999s) # remove intermediate steps

state_code <- '27' # use this for testing

#######################################
## CDP to County Subdivision Mapping ##
#######################################

Census_Place_2010 <- st_read(paste("Census_Geographies/2010_place/tl_2010_", state_code,"_place10/tl_2010_", state_code, "_place10.shp", sep = "")) # bring in Census Place level geometries
Census_CDPs_2010 <- Census_Place_2010 %>% filter(grepl('CDP', NAMELSAD10)) #filter to only CDPs
Census_CDPs_2010 <- subset(Census_CDPs_2010, select = -c(PCICBSA10, PCINECTA10,STATEFP10,INTPTLAT10,INTPTLON10,ALAND10,AWATER10,FUNCSTAT10,LSAD10,CLASSFP10,MTFCC10)) # remove extraneous fields

CDP_bounds <- st_bbox(Census_CDPs_2010) # get the bounding box for the CDPs in this state
CDP_centroid_lon <- (CDP_bounds[1] + CDP_bounds[3])/2 # average the longs
CDP_centroid_lat <- (CDP_bounds[2] + CDP_bounds[4])/2 # average the lats

# function below is adapted from code by Gordon McDonald from 8/10/2021, found here: https://gis.stackexchange.com/questions/13291/computing-utm-zone-from-lat-long-point

find_one_utm_zone <- function(longitude, latitude) { # function to find the right UTM zone
  if ( (latitude>-80.0) && (latitude<=84.0) ){
    mid_zones <- LETTERS[c(3:8,10:14,16:24)] # C to X, skip I and O
    utm_letter <- mid_zones[ min(floor( (latitude + 80) / 8 )+1 , 20) ]
    utm_number <- (floor( (longitude + 180) / 6 ) %% 60) + 1 # modulo in case longitude is 0 to 360 instead of -180 to 180
    utm_zone <- paste0(utm_number, utm_letter)
    return(utm_zone)
  } else {
      stop("lat long not valid (or something else broke)")
    }
}

utm_zone <- find_one_utm_zone(CDP_centroid_lon, CDP_centroid_lat) # find the right UTM zone
CDP_2010_Proj <- st_transform(Census_CDPs_2010, paste0("+proj=utm +zone=",utm_zone," +ellps=GRS80 +datum=NAD83", sep="")) #reproject to correct UTM zone
CDP_2010_Neg_Buffer <- CDP_2010_Proj %>% st_buffer(-300)  # create the negative 1000 foot buffer

Census_Cousubs_2010 <- st_read(paste("Census_Geographies/2010_cousub/tl_2010_", state_code,"_cousub10/tl_2010_", state_code, "_cousub10.shp", sep = "")) # bring in Census Place level geometries
Census_Cousubs_2010 <- subset(Census_Cousubs_2010, select = -c(CNECTAFP10,NECTAFP10,NCTADVFP10,STATEFP10,INTPTLAT10,INTPTLON10,ALAND10,AWATER10,FUNCSTAT10,LSAD10,MTFCC10))
Cousubs_2010_Proj <- Census_Cousubs_2010 %>% sf::st_transform(paste0("+proj=utm +zone=",utm_zone," +ellps=GRS80 +datum=NAD83", sep="")) # reproject to UTM projection specified above

CDP_Correspondence_Table <- st_join(CDP_2010_Neg_Buffer, Cousubs_2010_Proj, suffix = c("_CDP", "_Cousub"))
CDP_Correspondence_Table <- st_drop_geometry(CDP_Correspondence_Table) # remove geometry
CDP_Correspondence_Table <- subset(CDP_Correspondence_Table, select = -c(CLASSFP10)) # remove extra field that we might use elsewhere but not now

CDPs_with_Munis_Duplicates_Total <- duplicated(pull(CDP_Correspondence_Table,PLACEFP10)) | duplicated(pull(CDP_Correspondence_Table,PLACEFP10), fromLast=TRUE) # get duplicates and originals
CDPs_with_Munis_Duplicates_Total_List <- CDP_Correspondence_Table[CDPs_with_Munis_Duplicates_Total,c("NAMELSAD10_CDP", "NAMELSAD10_Cousub")]

# USE THIS TO PULL ROWS OUT OF THE MAIN DATASET

### END THIS SECTION

CDP_to_Cousub_Mapping <- filter(CDP_to_Cousub_Mapping, MUNI_MUN_LABEL != 'Byram Township') # remove one of the ambiguous CDPs since all housing units are in Sparta Township

place_PSH_CDPs_with_Munis <- left_join(place_PSH_CDPs, CDP_to_Cousub_Mapping, by = "code") # put them together

CDPs_with_Munis_Duplicates <- duplicated(pull(place_PSH_CDPs_with_Munis,name)) | duplicated(pull(place_PSH_CDPs_with_Munis,name), fromLast=TRUE)

CDPs_with_Ambiguous_or_Missing_Munis <- place_PSH_CDPs_with_Munis[CDPs_with_Munis_Duplicates, c('name','code',"MUNI_MUN_LABEL")]
#subset(place_PSH_CDPs_with_Munis,duplicated(name))

place_PSH_CDPs_Manual <- filter(place_PSH_CDPs_with_Munis, is.na(MUNI_MUN_LABEL))

place_PSH_CDPs_Manual <- filter(place_PSH_CDPs_with_Munis, is.na(MUNI_MUN_LABEL))
place_PSH_CDPs_with_Munis <- filter(place_PSH_CDPs_with_Munis, !is.na(MUNI_MUN_LABEL))
place_PSH_CDPs_with_Munis$CENSUS2010 <- place_PSH_CDPs_with_Munis$MUNI_CENSUS2010 # need a common join field later

rm(place_PSH_CDPs, place_PSH_CDPs_Manual) # get rid of earlier issues


```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
